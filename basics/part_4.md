# Basics Part 4: Automating Virtual machine deployment

Before we can get in to the wonderfull world of linux, we'll automate the deployment of Virtual machines a litle bit.  
We'll set up a small PowerShell script that will make deploying Virtual Machines a bit easier.  

Basicly, our script will create and configure the Virtual Machine, register it in the DNS and reserve an IP address in the DHCP server.  
We already have our Hyper-V and DNS services installed, so all we still need is DHCP.  

## Setting up Windows DHCP Server

First, let's install and configure the Windows DHCP Server role:

```Powershell
Install-WindowsFeature DHCP -IncludeManagementTools
netsh dhcp add securitygroups
Add-DhcpServerInDC -DnsName "Base-1.yourdomain.local" -IPAddress 172.16.1.1
Set-DhcpServerv4FilterList -Allow $True
```

Note that we've set the DHCP to only give IP addresses to known hosts.  
Next, let's set up a DHCP scope for our internal `Admin LAN`, the `172.16.1.0/24` subnet:

```Powershell
Add-DhcpServerv4Scope -name "Admin LAN" -StartRange 172.16.1.2 -EndRange 172.16.1.253 -SubnetMask 255.255.255.0 -State Active
Set-DhcpServerv4OptionValue -ScopeId 172.16.1.0 -DnsDomain "yourdomain.local" -DnsServer 172.16.1.1 -Router 172.16.1.254
```

And that's it for the DHCP setup.  
We're all set to start writing our script.  

## A basic VM-deploy automation script

I've been calling it a script, but it's actually a module.  
A powershell module can be imported and various functions inside it can be executed once it hs been imported.  

I'll be storing my scripts and modules under `C:\projects\scripts`.  
I set this direcory up as git repo, which is publicly available [here](https://github.com/kazaamjt/Scripts).  

The first module will be `VMAutomation.psm1`.  
We'll be adding cmdlet's to it if, and when they come up.  

For now, let's start with one that helps us deploy virtual machines in some basic ways.  
First, let's set up the name and parameters of the function:

```Powershell
function New-AutoDeployVM {
    [CmdletBinding()]
    Param(
        # Used to name the virtual machine, set up DNS records and register with the DHCP server.
        [Parameter(Mandatory=$true, Position=0)]
        [string]$Name,

        # Specifies the target Hyper-V Server.
        [Parameter(Mandatory=$true, Position=1)]
        [string]$VMHost,

        # The directory used to store the vm will be $Path\$Name
        [string]$Path="D:\AutoDeployVMS",

        # Specifies the number of CPU Cores. Defaults to 1.
        [int]$CPUCount=1,

        # Wether to use dynamic ram or not
        [switch]$DynamicRam,

        # Specifies Startup Memory.
        [int64]$StartUpRam=1024MB,

        # Specifies the Minimum amount of dynamic.
        [int64]$MinRam=512MB,

        # Specifies the Maximum amount of dynamic.
        [int64]$MaxRam=2048MB,

        [UInt64]$DiskSize=40GB,

        [string]$SwitchName,

        [IPAddress]$SubnetAddress,

        [ValidateSet("Nothing", "Start", "StartIfRunning")]
        [string]$AutomaticStartAction = "StartIfRunning",

        [ValidateSet("Save", "ShutDown", "TurnOff")]
        [string]$AutomaticStopAction = "ShutDown",

        [int64]$AutomaticStartDelay=60,

        [string]$ISOPath="path/to/debian/iso",

        # Notes that can be added to the VM.  
        [string]$Notes="AutoGenerated VM"
    )

}
```

This basic set of parameters will serve us for now.  
Go over all of them and correct for your system where needed.  
We'll add more parameters as as they come up.  

Now bear with me, as the next part is a bit longer.  
In the function body:

```Powershell
    # Set up the required directories
    $VMDir = "$Path\$Name"
    Invoke-Command -ComputerName $VMHost -ScriptBlock {
        param($Path)
        New-Item -Path $VMDir -ItemType Directory
        New-Item -Path "$VMDir\VM" -ItemType Directory
    } -Args $VMDir

    # Creating the VM with all the required bells and whistles
    New-VM -Name $Name -ComputerName $VMHost `
    -NoVHD -Path "$VMDir\VM" `
    -MemoryStartupBytes $StartUpRam -SwitchName $SwitchName `
    -Generation 2 -BootDevice "CD"

    Set-VM -Name $Name -ComputerName $VMHost -ProcessorCount $CPUCount `
    -AutomaticStartAction $AutomaticStartAction -AutomaticStopAction $AutomaticStopAction `
    -AutomaticStartDelay $AutomaticStartDelay -Notes $Notes

    if ($DynamicRam) {
        Set-VM -Name $Name -ComputerName $VMHost -DynamicMemory -MemoryMinimumBytes $MinRam -MemoryMaximumBytes $MaxRam
    }
    Set-VMFirmware -VMName $Name -ComputerName $VMHost -EnableSecureBoot On -SecureBootTemplate "MicrosoftUEFICertificateAuthority"
    Set-VMDvdDrive -VMName $Name -ComputerName $VMHost -Path $ISOPath

    # Create the virtual hard disk
    $VHDPath = "$VMDir\$Name.vhdx"
    New-VHD -ComputerName $VMHost -Path $VHDPath -Dynamic -SizeBytes 40GB
    Add-VMHardDiskDrive -ComputerName $VMHost -VMName $Name -Path $VHDPath
```

This will create the VM and fully configure it.  
It can even be used to deploy a VM on another HyperV server in the same domain.  

First, we create the required Directories on the target machine.  
Because `New-item` does not have a `-ComputerName` parameter, we'll instead send it over using `Invoke-Command`.  
`Invoke-Command` remotely executes one or more commands.  
In our case even a full script.  

Next we create the Virtual Hard Disk.  
Followed by the VM itself.  
Then, because `New-VM` doesn't have all the properties we need to set,
we use `Set-VM` to set the several more parameters.  
And if dynamic memory is enabled, we set that too using `Set-VM`.  

Then seeing as how Debian supports `Hyper-V Secure boot`, I enable that and set the Template to the correct one.  
This is similar to the `Secure boot` in your own computers BIOS/UEFI.  

Finally, we mount the default iso we'd like to install.  

That leaves the matter of assigning an IP and registering our machine in DNS.  
Add parameters for the DHCP and DNS Servers if you spread out your roles over multiple Servers.  

Now we'll have to jump through a couple more hoops:  

```Powershell
    # Hyper-V generates a semi-random MacAddress at first boot
    Start-VM -ComputerName $VMHost -Name $Name
    Stop-VM -ComputerName $VMHost -Name $Name -TurnOff
    $MacAddress = (Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost).MacAddress
    Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost | Set-VMNetworkAdapter -StaticMacAddress $MacAddress

    # Register the IP in DHCP
    $IPAddress = Get-DhcpServerv4FreeIPAddress -ScopeId $SubnetAddress
    Add-DhcpServerv4Reservation -IPAddress $IPAddress -ScopeId $SubnetAddress -ClientId $MacAddress `
        -Name $Name -Description "Auto generated lease for VM autodeploy"
    Add-DhcpServerv4Filter -List Allow -MacAddress $MacAddress -Description $Name

    # Register in DNS
    Add-DnsServerResourceRecordA -Name $Name -CreatePtr -AllowUpdateAny -IPv4Address $IPAddress -AgeRecord -ZoneName yourdomain.local
```

This is "Good enough" for now.  
let's try it out:  

```Powershell
Import-Module C:\Projects\Scripts\VMAutomation.psm1

New-AutoDeployVM -Name test -VMHost base-1 -SwitchName "Admin Lan" -SubnetAddress 172.16.1.0
```

I called this machine test, because we're using it to verify that our command is working.  
For example, the default iso location in my first attempt was wrong.  
Start the machine to verify it works.  
Using DHCP the machine get an IP address assigned, and the hostname should also be automaticaly set correctly.  
I stopped the installation at this point.  

Now let's create a function that will clean up virtual machines:  
First, let's set the parameters, we only need 3:

```Powershell
function Remove-AutoDeployVM {
    [CmdletBinding()]
    param (
        # Name of the VM, dns records, dhcp lease etc.
        [Parameter(Mandatory=$true, Position=0)]
        [string]$Name,

        # The Hyper-V server hosting the machine.
        [Parameter(Mandatory=$true, Position=1)]
        [string]$VMHost,

        # The directory used to store the vm will be $Path\$Name
        [string]$Path="D:\AutoDeployVMS"
    )

}
```

First thing we need to do is stop the VM:

```Powershell
    # Kill the VM if it is running
    Stop-VM -ComputerName $VMHost -Name $Name -TurnOff -WarningAction SilentlyContinue
```

Next, let's clean up the DNS records:

```Powershell
    # Clean up DNS
    (Get-DnsServerResourceRecord -RRType Ptr -ZoneName 16.172.in-addr.arpa) `
        | Where-Object {$_.RecordData.PtrDomainName -eq "$Name.ServerCademy.local."} `
        | Remove-DnsServerResourceRecord -ZoneName 16.172.in-addr.arpa -Force
    Remove-DnsServerResourceRecord -ZoneName ServerCademy.local -RRType "A" -Name $Name -Force
```

Then, let's delete the DHCP reservation:  

```Powershell
    # Clean up DHCP
    $MacAddress = (Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost).MacAddress
    Remove-DhcpServerv4Filter -MacAddress $MacAddress
    foreach ($Scope in Get-DhcpServerv4Scope) {
        Get-DhcpServerv4Reservation -ScopeId $Scope.ScopeId.IPAddressToString -ClientId $MacAddress | Remove-DhcpServerv4Reservation
    }
```

Finaly, let's clean up the VM itself:

```Powershell
    # Remove VM
    Remove-VM -ComputerName $VMHost -Name $Name -Force

    # Clean up Files
    Invoke-Command -ComputerName $VMHost -ScriptBlock {
        param($Name, $Path)
        Remove-Item -Path "$Path\$Name" -Recurse -Force
    } -Args $Name, $Path
```

Again, make sure to test and tweak it as needed:

```Powershell
Import-Module C:\Projects\Scripts\VMAutomation.psm1 -Force

Remove-AutoDeployVM -Name test -VMHost Base-1
```

Be sure to double check that all resources are properly cleaned up.  
The full module can be seen at the end, after the navigation buttons.  

Finaly, let's use our newly created Powershell module to create 3 Virtual Machines that we'll use at a later point in time.  

```Powershell
New-AutoDeployVM -Name AutomationStation -VMHost base-1 -SwitchName "Admin Lan" -SubnetAddress 172.16.1.0 -StartUpRam 1048MB
New-AutoDeployVM -Name AdminPostgres -VMHost base-1 -SwitchName "Admin Lan" -SubnetAddress 172.16.1.0 -StartUpRam 1024MB
New-AutoDeployVM -Name DebianBase -VMHost base-1 -SwitchName "Admin Lan" -SubnetAddress 172.16.1.0 -StartUpRam 1024MB
```

The first machine, will be used to help with automated deployment and it will host our orchestrator in the future.  
The second machine will host Postgres services, that can be used by various services as a database backend.  
The third will be used as a basis for later debian based VMs.  

I'll go over the installation of Debian quickly in the next part.  

[< Basics Part 3: Putting SSO to the test](/basics/part_3.md)

```Powershell
function New-AutoDeployVM {
    [CmdletBinding()]
    Param(
        # Used to name the virtual machine, set up DNS records and register with the DHCP server.
        [Parameter(Mandatory=$true, Position=0)]
        [string]$Name,

        # Specifies the target Hyper-V Server.
        [Parameter(Mandatory=$true, Position=1)]
        [string]$VMHost,

        # The directory used to store the vm will be $Path\$Name
        [string]$Path="D:\AutoDeployVMS",

        # Specifies the number of CPU Cores. Defaults to 1.
        [int]$CPUCount=1,

        # Wether to use dynamic ram or not
        [switch]$DynamicRam,

        # Specifies Startup Memory.
        [int64]$StartUpRam=1024MB,

        # Specifies the Minimum amount of dynamic.
        [int64]$MinRam=512MB,

        # Specifies the Maximum amount of dynamic.
        [int64]$MaxRam=2048MB,

        [UInt64]$DiskSize=40GB,

        [string]$SwitchName="BackBone",

        [IPAddress]$SubnetAddress,

        [ValidateSet("Nothing", "Start", "StartIfRunning")]
        [string]$AutomaticStartAction = "StartIfRunning",

        [ValidateSet("Save", "ShutDown", "TurnOff")]
        [string]$AutomaticStopAction = "ShutDown",

        [int64]$AutomaticStartDelay=60,

        [string]$ISOPath="F:\ISOs\Debian\Debian-10.6.0.iso",

        # Notes that can be added to the VM.  
        [string]$Notes="AutoGenerated VM"
    )

    # Set up the required directories
    $VMDir = "$Path\$Name"
    Invoke-Command -ComputerName $VMHost -ScriptBlock {
        param($VMDir)
        New-Item -Path $VMDir -ItemType Directory
        New-Item -Path "$VMDir\VM" -ItemType Directory
    } -Args $VMDir

    # Creating the VM with all the required bells and whistles
    New-VM -Name $Name -ComputerName $VMHost `
    -NoVHD -Path "$VMDir\VM" `
    -MemoryStartupBytes $StartUpRam -SwitchName $SwitchName `
    -Generation 2 -BootDevice "CD"

    Set-VM -Name $Name -ComputerName $VMHost -ProcessorCount $CPUCount `
    -AutomaticStartAction $AutomaticStartAction -AutomaticStopAction $AutomaticStopAction `
    -AutomaticStartDelay $AutomaticStartDelay -Notes $Notes

    if ($DynamicRam) {
        Set-VM -Name $Name -ComputerName $VMHost -DynamicMemory -MemoryMinimumBytes $MinRam -MemoryMaximumBytes $MaxRam
    }
    Set-VMFirmware -VMName $Name -ComputerName $VMHost -EnableSecureBoot On -SecureBootTemplate "MicrosoftUEFICertificateAuthority"
    Set-VMDvdDrive -VMName $Name -ComputerName $VMHost -Path $ISOPath

    # Create the virtual hard disk
    $VHDPath = "$VMDir\$Name.vhdx"
    New-VHD -ComputerName $VMHost -Path $VHDPath -Dynamic -SizeBytes 40GB
    Add-VMHardDiskDrive -ComputerName $VMHost -VMName $Name -Path $VHDPath

    # Hyper-V generates a semi-random MacAddress at first boot
    Start-VM -ComputerName $VMHost -Name $Name
    Stop-VM -ComputerName $VMHost -Name $Name -TurnOff
    $MacAddress = (Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost).MacAddress
    Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost | Set-VMNetworkAdapter -StaticMacAddress $MacAddress

    # Register the IP in DHCP
    $IPAddress = Get-DhcpServerv4FreeIPAddress -ScopeId $SubnetAddress
    Add-DhcpServerv4Reservation -IPAddress $IPAddress -ScopeId $SubnetAddress -ClientId $MacAddress `
        -Name $Name -Description "Auto generated lease for VM autodeploy"
    Add-DhcpServerv4Filter -List Allow -MacAddress $MacAddress -Description $Name

    # Register in DNS
    Add-DnsServerResourceRecordA -Name $Name -CreatePtr -AllowUpdateAny -IPv4Address $IPAddress -AgeRecord -ZoneName ServerCademy.local
}

function Remove-AutoDeployVM {
    [CmdletBinding()]
    param (
        # Name of the VM, dns records, dhcp lease etc.
        [Parameter(Mandatory=$true, Position=0)]
        [string]$Name,

        # The Hyper-V server hosting the machine.
        [Parameter(Mandatory=$true, Position=1)]
        [string]$VMHost,

        # The directory used to store the vm will be $Path\$Name
        [string]$Path="D:\AutoDeployVMS"
    )

    # Kill the VM if it is running
    Stop-VM -ComputerName $VMHost -Name $Name -TurnOff -WarningAction SilentlyContinue

    # Clean up DNS
    (Get-DnsServerResourceRecord -RRType Ptr -ZoneName 16.172.in-addr.arpa) `
        | Where-Object {$_.RecordData.PtrDomainName -eq "$Name.ServerCademy.local."} `
        | Remove-DnsServerResourceRecord -ZoneName 16.172.in-addr.arpa -Force
    Remove-DnsServerResourceRecord -ZoneName ServerCademy.local -RRType "A" -Name $Name -Force

    # Clean up DHCP
    $MacAddress = (Get-VMNetworkAdapter -VMName $Name -ComputerName $VMHost).MacAddress
    Remove-DhcpServerv4Filter -MacAddress $MacAddress
    foreach ($Scope in Get-DhcpServerv4Scope) {
        Get-DhcpServerv4Reservation -ScopeId $Scope.ScopeId.IPAddressToString -ClientId $MacAddress | Remove-DhcpServerv4Reservation
    }

    # Remove VM
    Remove-VM -ComputerName $VMHost -Name $Name -Force

    # Clean up Files
    Invoke-Command -ComputerName $VMHost -ScriptBlock {
        param($Name, $Path)
        Remove-Item -Path "$Path\$Name" -Recurse -Force
    } -Args $Name, $Path
}
```
